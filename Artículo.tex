\documentclass{article}
\usepackage[hidelinks]{hyperref}
\usepackage[spanish,mexico]{babel}
\usepackage[raggedright]{titlesec}
\usepackage{listingsutf8}
\usepackage{color}
\usepackage[svgnames]{xcolor}
\usepackage[most]{tcolorbox}
\usepackage[tikz]{bclogo}
\usepackage{pst-blur}
\usepackage{fancyhdr}
\usepackage{hyphenat}

\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\rfoot{pág. \thepage}

%\titlespacing*{\subsection} {2ex}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
%\titlespacing*{\subsubsection}{4ex}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\newcommand{\code}[1]{\tcbox{\texttt{#1}}}
\newcommand{\codejs}[1]{\tcbox{\lstinline[style=ES6]{#1}}}
\newcommand{\operator}[2]{\item \textbf{#1} \codejs{#2}:}

\colorlet{lightgray}{gray!20}
\tcbset{on line, 
        boxsep=4pt, left=0pt,right=0pt,top=0pt,bottom=0pt,
        colframe=white,colback=lightgray,  
        highlight math style={enhanced}
}

\lstset{
     literate=%
         {á}{{\'a}}1
         {í}{{\'i}}1
         {é}{{\'e}}1
         {ý}{{\'y}}1
         {ú}{{\'u}}1
         {ó}{{\'o}}1
         {ě}{{\v{e}}}1
         {š}{{\v{s}}}1
         {č}{{\v{c}}}1
         {ř}{{\v{r}}}1
         {ž}{{\v{z}}}1
         {ď}{{\v{d}}}1
         {ť}{{\v{t}}}1
         {ň}{{\v{n}}}1                
         {ů}{{\r{u}}}1
         {Á}{{\'A}}1
         {Í}{{\'I}}1
         {É}{{\'E}}1
         {Ý}{{\'Y}}1
         {Ú}{{\'U}}1
         {Ó}{{\'O}}1
         {Ě}{{\v{E}}}1
         {Š}{{\v{S}}}1
         {Č}{{\v{C}}}1
         {Ř}{{\v{R}}}1
         {Ž}{{\v{Z}}}1
         {Ď}{{\v{D}}}1
         {Ť}{{\v{T}}}1
         {Ň}{{\v{N}}}1                
         {Ů}{{\r{U}}}1    
}
\lstset{framesep=10pt}
\lstset{xleftmargin=10pt,xrightmargin=10pt}

\lstalias[]{ES6}[ECMAScript2015]{JavaScript}
\lstdefinelanguage{JavaScript}{
  morekeywords=[1]{break, continue, delete, else, for, function, if, in,
    new, return, this, typeof, var, void, while, with},
  % Literals, primitive types, and reference types.
  morekeywords=[2]{false, null, true, boolean, number, undefined,
    Array, Boolean, Date, Math, Number, String, Object},
  % Built-ins.
  morekeywords=[3]{eval, parseInt, parseFloat, escape, unescape},
  sensitive,
  morecomment=[s]{/*}{*/},
  morecomment=[l]//,
  morecomment=[s]{/**}{*/}, % JavaDoc style comments
  morestring=[b]',
  morestring=[b]"
}[keywords, comments, strings]

\lstdefinelanguage[ECMAScript2015]{JavaScript}[]{JavaScript}{
  morekeywords=[1]{await, async, case, catch, class, const, default, do,
    enum, export, extends, finally, from, implements, import, instanceof,
    let, static, super, switch, throw, try},
  morestring=[b]` % Interpolation strings.
}

\definecolor{mediumgray}{rgb}{0.3, 0.4, 0.4}
\definecolor{mediumblue}{rgb}{0.0, 0.0, 0.8}
\definecolor{forestgreen}{rgb}{0.13, 0.55, 0.13}
\definecolor{darkviolet}{rgb}{0.58, 0.0, 0.83}
\definecolor{royalblue}{rgb}{0.25, 0.41, 0.88}
\definecolor{crimson}{rgb}{0.86, 0.8, 0.24}

\lstdefinestyle{JSES6Base}{
  backgroundcolor=\color{white},
  basicstyle=\ttfamily,
  breakatwhitespace=false,
  breaklines=false,
  %captionpos=b,
  columns=fullflexible,
  commentstyle=\color{mediumgray}\upshape,
  emph={},
  emphstyle=\color{crimson},
  extendedchars=true,  % requires inputenc
  fontadjust=true,
  frame=single,
  identifierstyle=\color{black},
  keepspaces=true,
  keywordstyle=\color{mediumblue},
  keywordstyle={[2]\color{darkviolet}},
  keywordstyle={[3]\color{royalblue}},
  %numbers=left,
  numbersep=5pt,
  numberstyle=\tiny\color{black},
  rulecolor=\color{black},
  showlines=true,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stringstyle=\color{forestgreen},
  tabsize=2,
  %title=\lstname,
  upquote=true  % requires textcomp
}

\lstdefinestyle{JavaScript}{
  language=JavaScript,
  style=JSES6Base
}
\lstdefinestyle{ES6}{
  language=ES6,
  style=JSES6Base
}


\begin{document}
\title{\Large{\textbf{Principios y Patrones de Programación Funcional}}}
\author{César Alejandro González Ortega}
\date{18 de Noviembre del 2021 \\
  \bigskip\normalsize{Herramientas para la Comunicación Científica, Facultad de Matemáticas de la Universidad Autónoma de Yucatán}}
\maketitle


\pagebreak
\section*{Resumen}
Este artículo comienza con una introducción a la programación, posteriormente se explican algunos conceptos básicos de la programación imperativa con ejemplos en JavaScript, luego se hace una introducción a la programación funcional, sus principios y patrones básicos con ejemplos en JavaScript y finalmente se describen dos arquitecturas funcionales, una para aplicaciones de consola y otra para aplicaciones web.

El tema principal de este artículo es la programación funcional, para ello es necesario entender conceptos de programación en general y la sintaxis básica del lenguaje de programación en el que están escritos los ejemplos de código. Si ya conoces la sintaxis de JavaScript, puedes saltar a la sección \textbf{\ref{sec:fp-intro}. \nameref{sec:fp-intro}} en la pág. \pageref{sec:fp-intro}.

\section{Introducción a la programación}
A grandes rasgos, las computadoras son máquinas que pueden guardar datos y hacer operaciones controladas por programas. Los programas le brindan instrucciones y datos a una computadora para indicar qué operaciones realizar, en qué orden, cuántas veces, en qué momento, etc. Sin programas, las computadoras solamente serían máquinas complicadas que convierten electricidad en calor.

Una desventaja de las computadoras es que no pueden convertir el lenguaje humano a datos e instrucciones, estas solamente pueden procesar \textit{bits}. Un bit es la unidad básica de información y puede tener dos estados: encendido o apagado, uno o cero, verdadero o falso. Tanto las instrucciones como los datos de las computadoras están representadas por secuencias de bits. A las secuencias de bits que pueden ser ejecutadas por una computadora se les llama \textit{lenguaje de máquina}.

La \textit{programación} es el acto de escribir programas para lograr tareas específicas. Actualmente los programadores no escriben programas en lenguaje de máquina, sino que escriben texto en un \textit{lenguaje de programación} y un programa llamado intérprete o compilador traduce el lenguaje de programación a lenguaje máquina\cite{compilers-and-interpreters}. El \textit{código fuente} (a veces llamado simplemente código) es texto plano escrito en un lenguaje de programación.

Existen diversos \textit{estilos de programación}, o \textit{paradigmas}. Los paradigmas de programación pueden ser categorizados en:
\begin{enumerate}
  \item \textbf{Imperativo:} Los programas son tratados como secuencias de instrucciones (algoritmos). Se escribe paso a paso cómo llegar a un resultado.
  \item \textbf{Declarativo:} Se describe cómo es el resultado deseado. El código fuente no muestra el procedimiento concreto para llegar a un resultado, sino sus características.
\end{enumerate}


\section{Sintaxis básica de JavaScript}
El lenguaje de programación que se va a usar para los ejemplos de código es JavaScript, por su accesibilidad y porque tiene las características suficientes para ser usado con un estilo imperativo, declarativo o híbrido\cite{why-js}. Este documento no es una exploración exhaustiva de JavaScript, por simplicidad hay detalles deliberadamente ignorados al definir algunas características del lenguaje.

\subsection{Datos primitivos}
Los datos primitivos son la unidad de información básica de los programas. En JavaScript los datos primitivos más usados son números, cadenas de caracteres y booleanos. Los números pueden ser enteros o decimales, y negativos o positivos. Las cadenas de caracteres almacenan datos que representan texto y para crearlas se delimitan los caracteres entre un par de comillas dobles \code{\textquotedbl\textquotedbl}. Los booleanos representan \textit{verdadero} o \textit{falso} y son usados principalmente en condicionales, las cuales se explicarán en breve.

\lstinputlisting[style=ES6]{code/primitives.js}

\begin{bclogo}[logo=\bcinfo, couleurBarre=orange, noborder=true, couleur=white]{Comentarios en el código fuente}
Habrás visto que en el bloque anterior hay unas barras grises \code{//} seguidas de texto. Esos son los \textit{comentarios}, texto en el código fuente que no se ejecuta y sirve para que el escritor del código le exprese al lector detalles que podrían ser pasados por alto.
\newline
Otra forma de escribir comentarios es delimitando texto con los símbolos \code{/*} al inicio y \code{*/} al final.
\end{bclogo}

\subsection{Variables}
Por otro lado, las variables son espacios en la memoria del programa que guardan un dato. Para indicar que se quiere crear una variable se usa la palabra clave \codejs{let} seguida del nombre de la variable. El operador de \textit{asignación} \codejs{=} indica qué valor guardar en la variable. Una variable puede ser asignada varias veces a lo largo del programa. Se puede acceder al dato guardado en una variable escribiendo el nombre de la variable.

\lstinputlisting[style=ES6]{code/variables.js}

\begin{bclogo}[logo=\bcinfo, couleurBarre=orange, noborder=true, couleur=white]{Inspeccionar datos}
Existen varias formas para presentar los datos de los programas hacia las personas, una de ellas es mediante la \textit{consola}. Una consola sirve, entre otras cosas, para intercambiar texto entre un programa y un usuario. En JavaScript se usa la instrucción \codejs{console.log( /* dato */ )} para escribir un dato del programa en la consola. A lo largo de este documento se usará un comentario a la derecha de dicha instrucción para indicar qué texto sería escrito en la consola.
\end{bclogo}

\subsection{Operadores}
Los operadores sirven para indicar una acción relacionada al manejo de datos. Los operadores, excepto el de asignación \code{=}, generan un nuevo dato a partir de datos existentes.

\medskip
Los operadores aritméticos realizan operaciones con números. Algunos operadores aritméticos en JavaScript son:
\begin{itemize}
  \operator{Suma}{+} Si se usa con números, calcula la suma de dos números. Si se usa con cadenas de caracteres, junta las cadenas en una nueva cadena.
  \operator{Resta}{-} Resta el numero derecho del izquierdo.
  \operator{Multiplicación}{*} Multiplica dos números.
  \operator{División}{/} Calcula la división del número izquierdo entre el derecho.
\end{itemize}
\lstinputlisting[style=ES6]{code/operators/arithmetic.js}

\medskip
Los operadores de comparación determinan la igualdad o desigualdad entre dos valores. Solo pueden generar datos booleanos. Algunos operadores de comparación en JavaScript son:
\begin{itemize}
  \operator{Igualdad}{===} Genera \code{true} solamente si los datos son \textit{iguales} entre sí.
  \operator{Desigualdad}{!==} Genera \code{true} solamente si los datos son \textit{diferentes} entre sí.
  \operator{Menor que}{<} Genera \code{true} solamente si el número izquierdo es \textit{menor} que el derecho.
  \operator{Mayor que}{>} Genera \code{true} solamente si el número izquierdo es \textit{mayor} que el derecho.
\end{itemize}
\lstinputlisting[style=ES6]{code/operators/comparison.js}

\medskip
Los operadores lógicos son similares a los operadores de comparación porque generan datos booleanos. Algunos operadores lógicos de JavaScript son:
\begin{itemize}
  \operator{AND}{\&\&} Genera \code{true} solamente si ambos datos son \code{true}.
  \operator{OR}{||} Genera \code{false} solamente si ambos datos son \code{false}.
  \operator{NOT}{!} Operador que recibe un solo booleano y genera su opuesto. Si recibe \code{true}, genera \code{false} y viceversa.
\end{itemize}
\lstinputlisting[style=ES6]{code/operators/logic.js}

\subsection{Condicionales}
Quizá te haya sorprendido que se dediquen tantos operadores al manejo de booleanos. Un booleano por sí solo no es muy interesante, su verdadero potencial recae en las condicionales y los ciclos. Las condicionales reciben booleanos para decidir si una secuencia de instrucciones será evaluada o no. La condicional más básica es el bloque \codejs{if}, su sintaxis es la siguiente:
\lstinputlisting[style=ES6]{code/conditionals/syntax-if.js}

El bloque anterior solamente denota la sintaxis, no es un ejemplo válido de JavaScript porque el bloque \codejs{if} requiere que haya un dato entre los paréntesis. Veamos un ejemplo que sí se pueda ejecutar:
\lstinputlisting[style=ES6]{code/conditionals/if.js}

Nótese que solo una instrucción de \codejs{console.log} fue evaluada. El programa no escribió \textquotedbl Buenos días\textquotedbl\medspace en la consola porque el booleano recibido en el bloque \codejs{if} era igual a \codejs{false}.

También es posible indicar instrucciones que se evaluarían solamente si no se evalúan las instrucciones dentro del \codejs{if}. Para ello se usa un bloque \codejs{else} y su sintaxis es la siguiente:
\lstinputlisting[style=ES6]{code/conditionals/syntax-else.js}
Un ejemplo de código que usa \codejs{else}:
\lstinputlisting[style=ES6]{code/conditionals/else.js}

\subsection{Ciclos}
Los ciclos son la respuesta a la pregunta ``¿Cómo se puede evaluar una instrucción múltiples veces sin tener que volver a escribirla?" Los ciclos son bloques de código similares a las condicionales porque su evaluación puede depender de un booleano. La diferencia es que los ciclos vuelven a ser evaluados si el booleano es \codejs{true}. El ciclo más básico es el bloque \codejs{while}, su sintaxis es la siguiente:
\lstinputlisting[style=ES6]{code/cicles/syntax-while.js}
Por ejemplo, para escribir en la consola múltiples veces el texto \textquotedbl Around the world\textquotedbl\medspace se hace lo siguiente:
\lstinputlisting[style=ES6]{code/cicles/infinite-while.js}
Este programa evalúa el \codejs{while}, como recibe \codejs{true} escribe \textquotedbl Around the world\textquotedbl\medspace en la consola, luego vuelve a evaluar el \codejs{while}, como recibe \codejs{true} escribe \textquotedbl Around the world\textquotedbl\medspace y así mientras el programa se mantenga prendido, nunca escribe \textquotedbl Inalcanzable\textquotedbl\medspace en la consola.

Se logró el cometido de evaluar una instrucción múltiples veces, pero se desveló un nuevo problema: ¿Cómo evitar que una instrucción se evalúe infinitas veces?. La respuesta es mediante el uso de variables. El booleano que recibe el bloque \codejs{while} puede depender de una variable que es reasignada dentro del ciclo. Veamos un ejemplo:
\lstinputlisting[style=ES6]{code/cicles/while.js}
Analicemos paso por paso qué hace este programa:
\begin{enumerate}
  \item Se crea la variable \codejs{número} y se le asigna el valor de \codejs{0}
  \item \codejs{while} recibe \codejs{true} como resultado de \codejs{0 < 3}, por lo que evalúa sus instrucciones:
  \begin{enumerate}
    \item Se escribe el dato guardado dentro de \codejs{número} en la consola. Es decir, se escribe \codejs{0} en la consola.
    \item Se calcula el resultado de \codejs{número + 1} y se le asigna a la variable \codejs{número}. Es decir, a \codejs{número} se le asigna \codejs{1}.
  \end{enumerate}
  \item \codejs{while} recibe \codejs{true} como resultado de \codejs{1 < 3}, por lo que evalúa sus instrucciones:
  \begin{enumerate}
    \item Se escribe el dato guardado dentro de \codejs{número} en la consola. Es decir, se escribe \codejs{1} en la consola.
    \item Se calcula el resultado de \codejs{número + 1} y se le asigna a la variable \codejs{número}. Es decir, a \codejs{número} se le asigna \codejs{2}.
  \end{enumerate}
  \item \codejs{while} recibe \codejs{true} como resultado de \codejs{2 < 3}, por lo que evalúa sus instrucciones:
  \begin{enumerate}
    \item Se escribe el dato guardado dentro de \codejs{número} en la consola. Es decir, se escribe \codejs{2} en la consola.
    \item Se calcula el resultado de \codejs{número + 1} y se le asigna a la variable \codejs{número}. Es decir, a \codejs{número} se le asigna \codejs{3}.
  \end{enumerate}
  \item \codejs{while} recibe \codejs{false} como resultado de \codejs{3 < 3}, por lo que sus instrucciones no son evaluadas y se termina el ciclo.
  \item Se escribe \textquotedbl Alcanzable :D\textquotedbl\medspace en la consola.
\end{enumerate}

Para que un ciclo no se repita infinitamente es necesario crear una variable. No basta solamente con crearla, la variable debe tener estas tres características:
\begin{enumerate}
  \item Debe guardar un dato antes de ser usada en el ciclo.
  \item Se debe usar la variable para decidir si las instrucciones del ciclo se van a evaluar.
  \item Al menos una instrucción dentro del ciclo debe asignar un nuevo dato en la variable.
\end{enumerate}
Las variables que cumplen con estas características son llamadas \textit{contadores}. Este patrón es tan común común que existe un ciclo que te permite definir las tres características del contador en una sola línea: el ciclo \codejs{for}. El ejemplo anterior puede ser reescrito de la siguiente forma usando un \codejs{for}:
\lstinputlisting[style=ES6]{code/cicles/for.js}
\begin{bclogo}[logo=\bcinfo, couleurBarre=orange, noborder=true, couleur=white]{Variables con acceso restringido}
En realidad los dos ejemplos de código no son exactamente iguales. La diferencia no es la sintaxis, sino qué pasa con la variable \codejs{número}. En el primer ejemplo la variable fue creada antes del ciclo \codejs{while} y se puede acceder a ella al terminar el ciclo, en el segundo es creada dentro del ciclo \codejs{for} y solamente se puede acceder a ella dentro del ciclo. Este comportamiento se debe al \textit{ámbito de la variable}\cite{scope}, tema amplio que no será cubierto a detalle en este documento. En resumen: si una variable es creada usando \codejs{let}, solo se puede acceder a ella desde el bloque en el que fue creada y desde los bloques creados dentro de su mismo bloque.
\end{bclogo}


\subsection{Estructuras de datos}
Son tipos de datos que contienen otros datos. A mí me gusta llamarlos \textit{datos compuestos}. Las estructuras de datos más comunes en JavaScript, mas no las únicas, son los \textit{arreglos} y los \textit{objetos}.
\subsubsection{Arreglos}
Un arreglo se puede ver como una colección de datos ordenados. Para crear un objeto se usa un par de corchetes \codejs{[ ]} y adentro se escriben sus datos separados por comas. Los datos se pueden acceder mediante su índice. El primer dato del arreglo corresponde al índice 0, el segundo al índice 1 y así sucesivamente. Se puede usar un operador de asignación para indicar qué dato guardar en un índice del arreglo. Para acceder al tamaño de un arreglo se usa su propiedad \code{length}.
\lstinputlisting[style=ES6]{code/data-structures/arrays.js}
Para hacer operaciones con los elementos de un arreglo es común usar ciclos donde el contador también es usado como índice del arreglo:
\lstinputlisting[style=ES6]{code/data-structures/arrays-in-for.js}
\subsubsection{Objetos}
¿Qué tal si en lugar de acceder a los elementos de una estructura de datos mediante su índice se accede mediante el nombre del elemento? Eso se puede hacer con un \textit{objeto}, un dato que guarda pares de nombre-dato (o clave-valor). A cada elemento de un objeto se le llama \textit{propiedad}. Para crear un objeto se usa un par de llaves \codejs{\{ \}} y adentro se escriben sus propiedades separadas por comas. Para acceder a una propiedad del objeto se usa el operador \textit{miembro} \codejs{.} seguido del nombre de la propiedad. Por ejemplo:
\lstinputlisting[style=ES6]{code/data-structures/objects.js}
\begin{bclogo}[logo=\bcinfo, couleurBarre=orange, noborder=true, couleur=white]{Estructuras de datos anidadas}
Los datos guardados en una estructura de datos no necesariamente deben ser primitivos, también pueden guardar otras estructuras de datos.
\end{bclogo}


\subsection{Funciones}
Una función es un conjunto de instrucciones que realiza una tarea o calcula un valor. Debe tomar alguna entrada y devolver una salida. En la \textit{declaración} de una función se definen cuáles son sus \textit{parámetros} (variables que van a guardar los datos de entrada), sus instrucciones y su \textit{valor de retorno} (dato de salida). En la \textit{llamada} de una función se evalúan sus instrucciones con los \textit{argumentos} (datos de entrada) especificados.\cite{functions}

La declaración de una función tiene la siguiente sintaxis:
\lstinputlisting[style=ES6]{code/functions/syntax.js}
Ejemplo de cómo declarar y llamar a una función que calcula el doble de un número:
\lstinputlisting[style=ES6]{code/functions/double.js}
Nótese que el \codejs{console.log} no es evaluado en la declaración de la función, sino en su llamada.

\begin{bclogo}[logo=\bcinfo, couleurBarre=orange, noborder=true, couleur=white]{Datos especiales}
En JavaScript existe un dato especial llamado \codejs{undefined}. Es el dato que guardan las variables a las que no se les asigna un dato, es el valor de retorno de las funciones sin \codejs{return}, es el dato que guardan los parámetros de una función invocada sin argumentos. \\
Otro dato especial de JavaScript es \codejs{NaN}, es el resultado de intentar hacer operaciones aritméticas con datos que no pueden ser procesados. Por ejemplo, \codejs{undefined * 2} o \codejs{0 / 0} generan como resultado \codejs{NaN}.
\end{bclogo}


\subsection{Características declarativas de JavaScript}
Todas las características del lenguaje abarcadas hasta el momento han sido imperativas, se especifican los pasos para llegar a un resultado. Las características declarativas de JavaScript no aportan funcionalidad que no pueda ser lograda con las características imperativas, sino que aportan sintaxis adicional para hacer ciertos bloques más legibles. En foros de Internet es común escuchar que tales características son azúcar sintáctica (\textit{syntactic sugar}). Algunas de esas características son:

\subsubsection{Desestructuración}
Sirve para guardar en variables los elementos de una estructura de datos sin usar el operador miembro.

\subsubsection{Operador resto \codejs{...}}

\subsubsection{Funciones flecha}


\section{Introducción a la programación funcional}
\label{sec:fp-intro}
La programación funcional no es un concepto nuevo. Sus raíces matemáticas (el cálculo lambda) se desarrollaron en la década de 1930 y el primer lenguaje de programación funcional (LISP) fue desarrollado en el año 1958. Sin embargo, este paradigma está captando cada vez más atención. Se escriben libros y se desarrollan librerías para usar patrones funcionales en lenguajes que no son puramente funcionales. Incluso lenguajes orientados a objetos están evolucionando para facilitar el uso de un estilo funcional. Este panorama hubiera sido impensable en los años 90, algo está cambiando.\cite{why-isnt-fp-norm}

Algunas características de la programación funcional son:
\begin{itemize}
  \item El código fuente sigue un estilo \textbf{declarativo}.
  \item Los programas resultantes tienen calidad y desempeño consistente.
  \item El código fuente puede llegar a ser muy simple. ``Una base simple produce código simple en la práctica" \medspace – Evan Czaplicki, creador de Elm\cite{mainstream-elm}.
  \item Se requiere menos esfuerzo mental para entender código funcional que código en un estilo imperativo\cite{skeptics-functional-style}.
  \item En una aplicación existente se pueden aplicar patrones funcionales esporádicamente, sin comprometerse a una arquitectura funcional\cite{skeptics-functional-style}.
\end{itemize}


\section{Principios y patrones de programación funcional}


\subsection{Las funciones también son datos}


\subsection{Inmutabilidad}


\subsection{Determinismo}


\subsection{Transparencia referencial}


\section{Arquitecturas funcionales}


\subsection{Puertos y adaptadores}
Esta sección está fuertemente inspirada por la plática ``Functional architecture – The pits of success"\cite{functional-architecture}


\subsection{La arquitectura Elm}
Esta sección está fuertemente inspirada por la plática ``Developer Happiness on the Front End with Elm"\cite{developer-happiness-elm}


\section{Corolario}


\pagebreak
\begin{thebibliography}{99}
  \bibitem{compilers-and-interpreters} \href{https://youtu.be/_C5AHaS1mOA}{Boiteau, D. (Escritor), y Beecroft, S. (Director). (1983). Computer Languages (Temporada 1, Episodio 6) [Episodio de programa de televisión]. En M. McManus (Productor ejecutivo), \textit{Bits and Bytes}. TVOntario.}
  \bibitem{why-js} \href{https://medium.com/javascript-scene/why-learn-functional-programming-in-javascript-composing-software-ea13afc7a257}{Elliot, E. (20 de febrero de 2017). \textit{Why Learn Functional Programming in JavaScript?}. Medium. https://medium.com/javascript-scene/why-learn-functional-programming-in-javascript-composing-software-ea13afc7a257}
  \bibitem{scope} \href{https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/scope\%20\&\%20closures/README.md\#you-dont-know-js-scope--closures}{Simpson, K. (2014) \textit{You Don't Know JS: Scope \& Closures}. O'Reilly Media, Inc.}
  \bibitem{functions} \href{https://developer.mozilla.org/es/docs/Web/JavaScript/Guide/Functions}{Developer.mozilla.org (15 de noviembre del 2021). \textit{Funciones - JavaScript | MDN}. https://developer.mozilla.org/es/docs/Web/JavaScript/Guide/Functions}
  \bibitem{why-isnt-fp-norm} \href{https://clojutre.org/2019/#feldman}{Feldman, R. (26-27 de septiembre de 2019). \textit{Why Isn't Functional Programming the Norm?} [Sesión de conferencia]. ClojuTRE, Helsinki, Finlandia. https://clojutre.org/2019/\#feldman}
  \bibitem{mainstream-elm} \href{https://youtu.be/oYk8CKH7OhE}{Czaplicki, E. (6-7 de junio de 2015). \textit{Let's be mainstream! User focused design in Elm} [Discurso principal]. Curry On, Praga, República Checa. https://youtu.be/oYk8CKH7OhE}
  \bibitem{skeptics-functional-style} \href{https://youtu.be/oF9XTJoScOE}{Mills, J. (21 de julio de 2017). \textit{A Skeptics Guide To Functional Style JavaScript} [Sesión de conferencia]. NEJS CONF, Omaha, Nebraska, Estados Unidos de América. https://youtu.be/oF9XTJoScOE}
  \bibitem{functional-architecture} \href{https://youtu.be/US8QG9I1XW0}{Seemann, M. (2016). \textit{Functional architecture – The pits of success} [Sesión de conferencia]. NDC Conferences, Sídney, Australia. https://youtu.be/US8QG9I1XW0}
  \bibitem{developer-happiness-elm} \href{https://youtu.be/kuOCx0QeQ5c}{Yank, K. (25 de mayo de 2017). \textit{Developer Happiness on the Front End with Elm} [Vídeo]. https://youtu.be/kuOCx0QeQ5c}
\end{thebibliography}

\end{document}