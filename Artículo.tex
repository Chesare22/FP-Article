\documentclass{article}
\usepackage{hyperref}
\usepackage[spanish,mexico]{babel}
\usepackage{titlesec}
\usepackage{listingsutf8}
\usepackage{color}
\usepackage[svgnames]{xcolor}
\usepackage[most]{tcolorbox}
\usepackage[tikz]{bclogo}
\usepackage{pst-blur}
\usepackage{fancyhdr}

\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\rfoot{pág. \thepage}

%\titlespacing*{\subsection} {2ex}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
%\titlespacing*{\subsubsection}{4ex}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\newcommand{\code}[1]{\tcbox{\texttt{#1}}}
\newcommand{\codejs}[1]{\tcbox{\lstinline[style=ES6]{#1}}}
\newcommand{\operator}[2]{\item \textbf{#1} \codejs{#2}:}

\colorlet{lightgray}{gray!20}
\tcbset{on line, 
        boxsep=4pt, left=0pt,right=0pt,top=0pt,bottom=0pt,
        colframe=white,colback=lightgray,  
        highlight math style={enhanced}
}

\lstset{
     literate=%
         {á}{{\'a}}1
         {í}{{\'i}}1
         {é}{{\'e}}1
         {ý}{{\'y}}1
         {ú}{{\'u}}1
         {ó}{{\'o}}1
         {ě}{{\v{e}}}1
         {š}{{\v{s}}}1
         {č}{{\v{c}}}1
         {ř}{{\v{r}}}1
         {ž}{{\v{z}}}1
         {ď}{{\v{d}}}1
         {ť}{{\v{t}}}1
         {ň}{{\v{n}}}1                
         {ů}{{\r{u}}}1
         {Á}{{\'A}}1
         {Í}{{\'I}}1
         {É}{{\'E}}1
         {Ý}{{\'Y}}1
         {Ú}{{\'U}}1
         {Ó}{{\'O}}1
         {Ě}{{\v{E}}}1
         {Š}{{\v{S}}}1
         {Č}{{\v{C}}}1
         {Ř}{{\v{R}}}1
         {Ž}{{\v{Z}}}1
         {Ď}{{\v{D}}}1
         {Ť}{{\v{T}}}1
         {Ň}{{\v{N}}}1                
         {Ů}{{\r{U}}}1    
}
\lstset{framesep=10pt}
\lstset{xleftmargin=10pt,xrightmargin=10pt}

\lstalias[]{ES6}[ECMAScript2015]{JavaScript}
\lstdefinelanguage{JavaScript}{
  morekeywords=[1]{break, continue, delete, else, for, function, if, in,
    new, return, this, typeof, var, void, while, with},
  % Literals, primitive types, and reference types.
  morekeywords=[2]{false, null, true, boolean, number, undefined,
    Array, Boolean, Date, Math, Number, String, Object},
  % Built-ins.
  morekeywords=[3]{eval, parseInt, parseFloat, escape, unescape},
  sensitive,
  morecomment=[s]{/*}{*/},
  morecomment=[l]//,
  morecomment=[s]{/**}{*/}, % JavaDoc style comments
  morestring=[b]',
  morestring=[b]"
}[keywords, comments, strings]

\lstdefinelanguage[ECMAScript2015]{JavaScript}[]{JavaScript}{
  morekeywords=[1]{await, async, case, catch, class, const, default, do,
    enum, export, extends, finally, from, implements, import, instanceof,
    let, static, super, switch, throw, try},
  morestring=[b]` % Interpolation strings.
}

\definecolor{mediumgray}{rgb}{0.3, 0.4, 0.4}
\definecolor{mediumblue}{rgb}{0.0, 0.0, 0.8}
\definecolor{forestgreen}{rgb}{0.13, 0.55, 0.13}
\definecolor{darkviolet}{rgb}{0.58, 0.0, 0.83}
\definecolor{royalblue}{rgb}{0.25, 0.41, 0.88}
\definecolor{crimson}{rgb}{0.86, 0.8, 0.24}

\lstdefinestyle{JSES6Base}{
  backgroundcolor=\color{white},
  basicstyle=\ttfamily,
  breakatwhitespace=false,
  breaklines=false,
  %captionpos=b,
  columns=fullflexible,
  commentstyle=\color{mediumgray}\upshape,
  emph={},
  emphstyle=\color{crimson},
  extendedchars=true,  % requires inputenc
  fontadjust=true,
  frame=single,
  identifierstyle=\color{black},
  keepspaces=true,
  keywordstyle=\color{mediumblue},
  keywordstyle={[2]\color{darkviolet}},
  keywordstyle={[3]\color{royalblue}},
  %numbers=left,
  numbersep=5pt,
  numberstyle=\tiny\color{black},
  rulecolor=\color{black},
  showlines=true,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stringstyle=\color{forestgreen},
  tabsize=2,
  %title=\lstname,
  upquote=true  % requires textcomp
}

\lstdefinestyle{JavaScript}{
  language=JavaScript,
  style=JSES6Base
}
\lstdefinestyle{ES6}{
  language=ES6,
  style=JSES6Base
}


\begin{document}
\title{\Large{\textbf{Principios y Patrones de Programación Funcional}}}
\author{César González}
\date{12 de Noviembre del 2021}
\maketitle


\pagebreak
\section*{Resumen}
Este artículo comienza diciendo la importancia de la programación funcional, posteriormente se explican los bloques básicos de la programación imperativa, luego se explica cómo usar esos mismos bloques en un estilo funcional con ejemplos en JavaScript, mencionando algunos principios y patrones funcionales, después se menciona brevemente qué son los objetos, posteriormente se menciona cómo son las pruebas unitarias en programas funcionales y finalmente se describen dos arquitecturas funcionales, una para aplicaciones de consola y otra para páginas web.

\section*{Introducción}
La programación funcional no es un concepto nuevo. Sus raíces matemáticas (el cálculo lambda) se desarrollaron en la década de 1930 y el primer lenguaje de programación funcional (LISP) fue desarrollado en el año 1958. Sin embargo, este paradigma está captando cada vez más atención. Se escriben libros y se desarrollan librerías para usar patrones funcionales en lenguajes que no son puramente funcionales. Incluso lenguajes orientados a objetos están evolucionando para facilitar el uso de un estilo funcional. Este panorama hubiera sido impensable en los años 90, algo está cambiando.\cite{why-isnt-fp-norm}

Algunas características de la programación funcional son:
\begin{itemize}
  \item Es fácil seguir el flujo de datos.
  \item El código fuente es fácil de modificar.
  \item El código fuente puede llegar a ser muy simple. ``Una base simple produce código simple en la práctica" \medspace – Evan Czaplicki, creador de Elm.\cite{mainstream-elm}
  \item En una aplicación existente se pueden aplicar patrones funcionales esporádicamente, sin comprometerse a una arquitectura funcional.\cite{skeptics-functional-style}
\end{itemize}


\section*{Programación imperativa}
Antes de hablar sobre programación funcional hay que hablar sobre programación imperativa por dos motivos principales: para tener un punto de referencia y porque muchos bloques usados para construir programas imperativos también se usan en la programación funcional.

El lenguaje de programación que se va a usar para los ejemplos de código es JavaScript, por su accesibilidad y porque tiene las características suficientes\cite{why-js} para ser usado con un estilo imperativo, funcional o híbrido. Este documento no es una exploración exhaustiva de JavaScript, por simplicidad hay detalles deliberadamente ignorados al definir algunas características del lenguaje.

\subsection*{Datos primitivos}
Los datos primitivos son la unidad de información básica de los programas. En JavaScript los datos primitivos más usados son números, cadenas de caracteres y booleanos. Los números pueden ser enteros o decimales, y negativos o positivos. Las cadenas de caracteres almacenan datos que representan texto y para crearlas se delimitan los caracteres entre un par de comillas dobles c. Los booleanos representan \textit{verdadero} o \textit{falso} y son usados principalmente en condicionales, las cuales se explicarán en breve.

\lstinputlisting[style=ES6]{code/primitives.js}

\begin{bclogo}[logo=\bcinfo, couleurBarre=orange, noborder=true, couleur=white]{Comentarios en el código fuente}
Habrás visto que en el bloque anterior hay unas barras grises \code{//} seguidas de texto. Esos son los comentarios, texto en el código fuente que no se ejecuta y sirve para que el escritor del código le exprese al lector detalles que podrían ser pasados por alto.
\newline
Otra forma de escribir comentarios es delimitando texto con los símbolos \code{/*} al inicio y \code{*/} al final.
\end{bclogo}

\subsection*{Variables}
Por otro lado, las variables son espacios en la memoria del programa que guardan un dato. Para indicar que se quiere crear una variable se usa la palabra clave \codejs{let} seguida del nombre de la variable. El operador de asignación \codejs{=} indica qué valor guardar en la variable. Una variable puede ser asignada varias veces a lo largo del programa. Se puede acceder al dato guardado en una variable escribiendo el nombre de la variable.

\lstinputlisting[style=ES6]{code/variables.js}

\begin{bclogo}[logo=\bcinfo, couleurBarre=orange, noborder=true, couleur=white]{Inspeccionar datos}
Existen varias formas para presentar los datos de los programas hacia las personas, una de ellas es mediante la consola. Una consola sirve, entre otras cosas, para intercambiar texto entre un programa y un usuario. En JavaScript se usa la instrucción \codejs{console.log( /* dato */ )} para escribir un dato del programa en la consola. A lo largo de este documento se usará un comentario a la derecha de dicha instrucción para indicar qué texto sería escrito en la consola.
\end{bclogo}

\subsection*{Operadores}
Los operadores sirven para indicar una acción relacionada al manejo de datos. Los operadores, excepto el de asignación \code{=}, generan un nuevo dato a partir de datos existentes.

\medskip
Los operadores aritméticos realizan operaciones con números. Algunos operadores aritméticos en JavaScript son:
\begin{itemize}
  \operator{Suma}{+} Si se usa con números, calcula la suma de dos números. Si se usa con cadenas de caracteres, junta las cadenas en una nueva cadena.
  \operator{Resta}{-} Resta el numero derecho del izquierdo.
  \operator{Multiplicación}{*} Multiplica dos números.
  \operator{División}{/} Calcula la división del número izquierdo entre el derecho.
\end{itemize}
\lstinputlisting[style=ES6]{code/operators/arithmetic.js}

\medskip
Los operadores de comparación determinan la igualdad o desigualdad entre dos valores. Solo pueden generar datos booleanos. Algunos operadores de comparación en JavaScript son:
\begin{itemize}
  \operator{Igualdad}{===} Genera \code{true} solamente si los datos son \textit{iguales} entre sí.
  \operator{Desigualdad}{!==} Genera \code{true} solamente si los datos son \textit{diferentes} entre sí.
  \operator{Menor que}{<} Genera \code{true} solamente si el número izquierdo es \textit{menor} que el derecho.
  \operator{Mayor que}{>} Genera \code{true} solamente si el número izquierdo es \textit{mayor} que el derecho.
\end{itemize}
\lstinputlisting[style=ES6]{code/operators/comparison.js}

\medskip
Los operadores lógicos son similares a los operadores de comparación porque generan datos booleanos. Algunos operadores lógicos de JavaScript son:
\begin{itemize}
  \operator{AND}{\&\&} Genera \code{true} solamente si ambos datos son \code{true}.
  \operator{OR}{||} Genera \code{false} solamente si ambos datos son \code{false}.
  \operator{NOT}{!} Operador que recibe un solo booleano y genera su opuesto. Si recibe \code{true}, genera \code{false} y viceversa.
\end{itemize}
\lstinputlisting[style=ES6]{code/operators/logic.js}

\subsection*{Condicionales}
Quizá te haya sorprendido que se dediquen tantos operadores al manejo de booleanos. Un booleano por sí solo no es muy interesante, su verdadero potencial recae en las condicionales. Las condicionales reciben booleanos para decidir si una secuencia de instrucciones será evaluada o no. La condicional más básica es el bloque \codejs{if}, su sintaxis es la siguiente:
\lstinputlisting[style=ES6]{code/conditionals/syntax-if.js}

El bloque anterior solamente denota la sintaxis, no es un ejemplo válido de JavaScript porque el bloque \codejs{if} requiere que haya un dato entre los paréntesis. Veamos un ejemplo que sí se pueda ejecutar:
\lstinputlisting[style=ES6]{code/conditionals/if.js}

Nótese que solo una instrucción de \codejs{console.log} fue evaluada. El programa no escribió \textquotedbl Buenos días\textquotedbl\medspace en la consola porque el booleano recibido en el bloque \codejs{if} era igual a \codejs{false}.

También es posible indicar un bloque que se evaluaría solamente si no se evalúan las instrucciones dentro del \codejs{if}. Tal bloque se conoce como \codejs{else} y su sintaxis es la siguiente:
\pagebreak
\lstinputlisting[style=ES6]{code/conditionals/syntax-else.js}
Un ejemplo de código que usa \codejs{else}:
\lstinputlisting[style=ES6]{code/conditionals/else.js}

\subsection*{Ciclos}
Los ciclos son la respuesta a la pregunta ``¿Cómo se puede evaluar una instrucción múltiples veces sin tener que volver a escribirla?" Los ciclos son bloques de código similares a las condicionales porque su evaluación puede depender de un booleano. La diferencia es que los ciclos vuelven a ser evaluados si el booleano es \codejs{true}. El ciclo más básico es el bloque \codejs{while}, su sintaxis es la siguiente:
\lstinputlisting[style=ES6]{code/cicles/syntax-while.js}
Por ejemplo, para escribir en la consola múltiples veces el texto \textquotedbl Around the world\textquotedbl\medspace se hace lo siguiente:
\pagebreak
\lstinputlisting[style=ES6]{code/cicles/infinite-while.js}
Este programa evalúa el \codejs{while}, como recibe \codejs{true} escribe \textquotedbl Around the world\textquotedbl\medspace en la consola, luego vuelve a evaluar el \codejs{while}, como recibe \codejs{true} escribe \textquotedbl Around the world\textquotedbl\medspace y así mientras el programa se mantenga prendido, nunca escribe \textquotedbl Inalcanzable\textquotedbl\medspace en la consola.

Se logró el cometido de evaluar una instrucción múltiples veces, pero se desveló un nuevo problema: ¿Cómo evitar que una instrucción se evalúe infinitas veces?. La respuesta es mediante el uso de variables. El booleano que recibe el bloque \codejs{while} puede depender de una variable que es reasignada dentro del ciclo. Veamos un ejemplo:
\lstinputlisting[style=ES6]{code/cicles/while.js}
Analicemos paso por paso qué hace este programa:
\begin{enumerate}
  \item Se crea la variable \codejs{número} y se le asigna el valor de \codejs{0}
  \item \codejs{while} recibe \codejs{true} como resultado de \codejs{0 < 3}, por lo que evalúa sus instrucciones:
  \begin{enumerate}
    \item Se escribe el dato guardado dentro de \codejs{número} en la consola. Es decir, se escribe \codejs{0} en la consola.
    \item Se calcula el resultado de \codejs{número + 1} y se le asigna a la variable \codejs{número}. Es decir, a \codejs{número} se le asigna \codejs{1}.
  \end{enumerate}
  \item \codejs{while} recibe \codejs{true} como resultado de \codejs{1 < 3}, por lo que evalúa sus instrucciones:
  \begin{enumerate}
    \item Se escribe el dato guardado dentro de \codejs{número} en la consola. Es decir, se escribe \codejs{1} en la consola.
    \item Se calcula el resultado de \codejs{número + 1} y se le asigna a la variable \codejs{número}. Es decir, a \codejs{número} se le asigna \codejs{2}.
  \end{enumerate}
  \item \codejs{while} recibe \codejs{true} como resultado de \codejs{2 < 3}, por lo que evalúa sus instrucciones:
  \begin{enumerate}
    \item Se escribe el dato guardado dentro de \codejs{número} en la consola. Es decir, se escribe \codejs{2} en la consola.
    \item Se calcula el resultado de \codejs{número + 1} y se le asigna a la variable \codejs{número}. Es decir, a \codejs{número} se le asigna \codejs{3}.
  \end{enumerate}
  \item \codejs{while} recibe \codejs{false} como resultado de \codejs{3 < 3}, por lo que sus instrucciones no son evaluadas y se termina el ciclo.
  \item Se escribe \textquotedbl Alcanzable :D\textquotedbl\medspace en la consola.
\end{enumerate}

Para que un ciclo no se repita infinitamente es necesario crear una variable. No solo basta con crearla, igual se debe hacer lo siguiente:
\begin{enumerate}
  \item Se le debe asignar un valor inicial.
  \item Se debe usar la variable para decidir si las instrucciones del ciclo se van a evaluar.
  \item Al menos una instrucción dentro del ciclo debe modificar la variable.
\end{enumerate}
Este patrón es tan común común que existe un ciclo que te permite definir estos tres aspectos en una sola línea: el ciclo \codejs{for}. El ejemplo anterior que usa un ciclo \codejs{while} puede ser reescrito de esta forma:
\lstinputlisting[style=ES6]{code/cicles/for.js}

\subsection*{Estructuras de datos}
Son tipos de datos que contienen otros datos. A mí me gusta llamarlos \textit{datos compuestos}. Las estructuras de datos más comunes en JavaScript, mas no las únicas, son los arreglos y los objetos.

Un arreglo se puede ver como una colección de datos ordenados. Los datos se pueden acceder mediante su índice. El primer dato del arreglo corresponde al índice 0, el segundo al índice 1 y así sucesivamente. Se puede usar el operador de asignación \code{=} para indicar qué dato guardar en un índice del arreglo.
\lstinputlisting[style=ES6]{code/arrays.js}

\subsection*{Funciones}

\section*{Programación funcional}

\subsection*{Las funciones también son datos}


\pagebreak
\begin{thebibliography}{99}
  \bibitem{why-isnt-fp-norm} \href{https://youtu.be/QyJZzq0v7Z4}{Why Isn't Functional Programming the Norm? – Richard Feldman at ClojuTRE 2019}
  \bibitem{mainstream-elm} \href{https://youtu.be/oYk8CKH7OhE?t=2133}{Let's be mainstream! User focused design in Elm – Evan Czaplicki at Curry On Prague! 2015}
  \bibitem{skeptics-functional-style} \href{https://youtu.be/oF9XTJoScOE?t=1253}{A Skeptics Guide To Functional Style JavaScript – Jonathan Mills at NEJS CONF 2017}
  \bibitem{why-js} \href{https://medium.com/javascript-scene/why-learn-functional-programming-in-javascript-composing-software-ea13afc7a257}{Why Learn Functional Programming in JavaScript? – Eric Elliot}
\end{thebibliography}

\end{document}